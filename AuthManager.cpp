#include "AuthManager.h"
#include <ctime>
#include <cstdlib>
#include <sstream>
#include <iomanip>
#include <iostream>

OTP::OTP() : 
    code(""),
    targetUser(""),
    expirationTime(0),
    purpose("") {
}

OTP::OTP(const std::string& targetUser, const std::string& purpose, int validityInMinutes) :
    targetUser(targetUser),
    purpose(purpose) {
    
    srand(static_cast<unsigned int>(time(NULL)));
    
    int randomCode = 100000 + (rand() % 900000);
    
    std::stringstream ss;
    ss << randomCode;
    code = ss.str();
    
    expirationTime = time(NULL) + validityInMinutes * 60;
}

std::string OTP::getCode() const {
    return code;
}

std::string OTP::getTargetUser() const {
    return targetUser;
}

std::string OTP::getPurpose() const {
    return purpose;
}

bool OTP::isValid() const {
    return time(NULL) < expirationTime;
}

AuthManager::AuthManager(DataManager& dm) 
    : currentLoggedInUser(""), dataManager(dm) {
}

std::string AuthManager::hashPassword(const std::string& password) const {
    unsigned long hash = 5381;
    for (size_t i = 0; i < password.length(); ++i) {
        hash = ((hash << 5) + hash) + password[i];
    }
    
    std::stringstream ss;
    ss << std::hex << std::setw(16) << std::setfill('0') << hash;
    return ss.str();
}

std::string AuthManager::generateRandomPassword(int length) const {
    const std::string chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*";
    
    srand(static_cast<unsigned int>(time(NULL) ^ (time(NULL) >> 16)));
    
    std::string password;
    for (int i = 0; i < length; i++) {
        int pos = rand() % chars.size();
        password += chars[pos];
    }
    
    return password;
}

bool AuthManager::registerUser(const std::string& username, 
                             const std::string& password, 
                             const std::string& fullName,
                             const std::string& email,
                             const std::string& phoneNumber,
                             UserRole role,
                             bool isAutoGenerated) {
    std::string actualPassword = password;
    bool passwordWasGenerated = false;
    
    if (password.empty() || isAutoGenerated) {
        actualPassword = generateRandomPassword();
        passwordWasGenerated = true;
    }
    
    std::string hashedPassword = hashPassword(actualPassword);
    
    User newUser(username, hashedPassword, fullName, email, phoneNumber, role);
    
    if (passwordWasGenerated) {
        newUser.setIsAutoGeneratedPassword(true);
        newUser.setIsFirstLogin(true);
    }
    
    bool success = dataManager.saveUser(newUser);
    
    if (success) {
        dataManager.saveData();
        std::cout << "User registered: " << username << std::endl;
        
        if (passwordWasGenerated) {
            std::cout << "Auto-generated password: " << actualPassword << std::endl;
        }
    } else {
        std::cout << "Failed to register user: " << username << std::endl;
    }
    
    return success;
}

bool AuthManager::registerUserByAdmin(const std::string& username, 
                                    const std::string& fullName,
                                    const std::string& email,
                                    const std::string& phoneNumber) {
    if (!isAdmin()) {
        std::cout << "Only administrators can register new users." << std::endl;
        return false;
    }
    
    bool result = registerUser(username, "", fullName, email, phoneNumber, REGULAR, true);
    
    return result;
}

bool AuthManager::login(const std::string& username, const std::string& password) {
    std::string hashedPassword = hashPassword(password);
    
    User* user = dataManager.getUser(username);
    if (!user || user->getPasswordHash() != hashedPassword) {
        return false;
    }
    
    currentLoggedInUser = username;
    
    user->setLastLoginDate(time(NULL));
    dataManager.saveUser(*user);
    dataManager.saveData();
    
    if (user->getIsAutoGeneratedPassword()) {
        std::cout << "WARNING: You are using an auto-generated password. ";
        std::cout << "Please change your password for security reasons." << std::endl;
    }
    
    return true;
}

void AuthManager::logout() {
    currentLoggedInUser = "";
}

bool AuthManager::changePassword(const std::string& username, 
                               const std::string& oldPassword, 
                               const std::string& newPassword) {
    std::string hashedOldPassword = hashPassword(oldPassword);
    
    User* user = dataManager.getUser(username);
    if (!user || user->getPasswordHash() != hashedOldPassword) {
        std::cout << "Old password is incorrect." << std::endl;
        return false;
    }
    
    std::string hashedNewPassword = hashPassword(newPassword);
    user->setPasswordHash(hashedNewPassword);
    
    if (user->getIsAutoGeneratedPassword()) {
        user->setIsAutoGeneratedPassword(false);
        user->setIsFirstLogin(false);
        std::cout << "Password updated successfully. Your account now has a custom password." << std::endl;
    } else {
        std::cout << "Password updated successfully." << std::endl;
    }
    
    bool success = dataManager.saveUser(*user);
    dataManager.saveData(); // Ensure data is written to file immediately
    return success;
}

bool AuthManager::resetPassword(const std::string& username) {
    if (currentLoggedInUser != username && !isAdmin()) {
        return false;
    }
    
    User* user = dataManager.getUser(username);
    if (!user) {
        std::cout << "User not found." << std::endl;
        return false;
    }
    
    std::string tempPassword = generateRandomPassword();
    std::string hashedTempPassword = hashPassword(tempPassword);
    
    user->setPasswordHash(hashedTempPassword);
    user->setIsAutoGeneratedPassword(true);
    user->setIsFirstLogin(true);
    
    bool success = dataManager.saveUser(*user);
    dataManager.saveData(); // Ensure data is written to file immediately
    if (success) {
        std::cout << "Password reset. Temporary password: " << tempPassword << std::endl;
    }
    
    return success;
}

bool AuthManager::generateOTP(const std::string& username, const std::string& purpose) {
    OTP otp(username, purpose);
    
    activeOTPs[username] = otp;
    
    std::cout << "OTP generated for " << username << ": " << otp.getCode() << std::endl;
    
    return true;
}

bool AuthManager::verifyOTP(const std::string& username, const std::string& otpCode) {
    std::map<std::string, OTP>::iterator it = activeOTPs.find(username);
    if (it == activeOTPs.end()) {
        std::cout << "No active OTP found for " << username << std::endl;
        return false;
    }
    
    OTP& otp = it->second;
    
    if (!otp.isValid()) {
        std::cout << "OTP expired" << std::endl;
        activeOTPs.erase(it);
        return false;
    }
    
    if (otp.getCode() != otpCode) {
        std::cout << "Invalid OTP" << std::endl;
        return false;
    }
    
    activeOTPs.erase(it);
    
    return true;
}

std::string AuthManager::getCurrentUser() const {
    return currentLoggedInUser;
}

bool AuthManager::isLoggedIn() const {
    return !currentLoggedInUser.empty();
}

bool AuthManager::isAdmin() const {
    if (!isLoggedIn()) {
        return false;
    }
    
    User* user = dataManager.getUser(currentLoggedInUser);
    if (!user) {
        return false;
    }
    
    return user->isAdmin();
}
